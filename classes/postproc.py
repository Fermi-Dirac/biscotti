# This class is a wrapper for the input/output from the pp.x (pp.exe) function of Quantum Espresso
# Please see "http://www.quantum-espresso.org/wp-content/uploads/Doc/pp_user_guide.pdf"
import os, sys, re
# import numpy as np
from collections import OrderedDict as odict
import datetime as dt
# import hashlib
# BUF_SIZE = 65536

# Setup a logger
import logging
from biscotti import setup_logger
logger = setup_logger(__name__, logging.INFO)


class PostProcIn(object):
    def __init__(self, name=None, inputpp=None, plot=None):
        """
        :param name: Quick name for this post processing calc
        :param inputpp: this is the dictionary of the input namelist
        :param plot: this is the ordered dictionary of the plot namelist
        """

        if inputpp is None:
            self.inputpp = odict()
        else:
            self.inputpp = odict(inputpp)
        if plot is None:
            self.plot = odict()
        else:
            self.plot = odict(plot)
        if name is None:
            if 'prefix' in self.inputpp:
                self.name = self.inputpp['prefix']
            else:
                self.name = 'Default'
        else:
            self.name = name

    def write_to_file(self, folder=None, filename = None):
        if folder is None:
            folder = os.getcwd()
        else:
            if not os.path.exists(folder):
                os.makedirs(folder)
        if filename is None:
            filename = re.sub(r'[\s\(\)]', "_", self.name)
        # Begin file write
        with open(folder + os.path.sep + filename, 'w') as newfile:
            newfile.write("! Quantum Espresso post processing (pp.x) input file.\n"
                          + '! Generated by Biscotti on ' + str(dt.datetime.now()))
            # Change flags for consistency
            self.check_consistency(fix = True)
            # Write namelists
            namelistdict = {'INPUTPP' : self.inputpp, 'PLOT' : self.plot}
            for namelistkey in namelistdict:
                newfile.write(' &' + str(namelistkey) + '\n')
                for key in namelistdict[namelistkey]:
                    logger.debug("Now on key" + str(key))
                    param = "  " + '{message: <{width}}'.format(message = str(key), width = 13) # keeps nice spacing
                    value = namelistdict[namelistkey][key]
                    logger.debug("Value is " + str(value) + " of type " + str(type(value)))
                    if type(value) is str:
                        value = "'" + value + "'"
                    elif type(value) is bool:
                        if value : # is true
                            value = ".true."
                        else:
                            value = ".false."
                    # TODO support for comments
                    comment = None
                    if comment is not None:
                        newline = param + " = " + str(value) + ", ! " + str(comment) + '\n'
                    else:
                        newline = param + " = " + str(value) + ",\n"
                    newfile.write(newline)
                newfile.write('/ \n\n')
            newfile.write('\n')
        logger.info('Successfully written pp.x input file :' + filename + ' to folder:' + folder)

    @staticmethod
    def import_from_file(path):
        pass

    def check_consistency(self, fix = False):
        inputpp_req_flags = ['prefix', 'filplot', 'plot_num']
        inputpp_req_flags_defaults = dict(zip(inputpp_req_flags, ['default', 'charge_density.ppout', 0]))
        plot_req_flags = ['iflag', 'output_format']
        plot_req_flags_defaults = dict(zip(plot_req_flags, [0, 0]))  # Default is 1D plot of spherical average for gnuplot

        for flag in inputpp_req_flags:
            if flag not in self.inputpp:
                logger.warning("Warning, pp.x flag '" + flag + "' was missing")
                if fix:
                    self.inputpp[flag] = inputpp_req_flags_defaults[flag]

        for flag in plot_req_flags:
            if flag not in self.plot:
                logger.warning("Warning, pp.x flag '" + flag + "' was missing")
                if fix:
                    self.inputpp[flag] = plot_req_flags_defaults[flag]

class PostProcOut(object):
    def __init__(self):
        pass